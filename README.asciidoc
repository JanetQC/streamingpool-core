
:source-highlighter: pygments

image:https://img.shields.io/travis/streamingpool/streamingpool-core/master.svg[]
image:https://img.shields.io/github/release/streamingpool/streamingpool-core.svg[]
image:https://img.shields.io/github/license/streamingpool/streamingpool-core.svg[]

== Getting Started
In order to use the Streaming Pool, just get the latest version from https://search.maven.org/#search%7Cga%7C1%7Ca%3A%22streamingpool-core%22[Maven Central].

Maven:
[source,xml]
----
<dependency>
    <groupId>org.streamingpool</groupId>
    <artifactId>streamingpool-core</artifactId>
    <version>X.Y.Z</version>
</dependency>
----
Gradle:
[source,groovy]
----
compile 'org.streamingpool:streamingpool-core:X.Y.Z'
----

It is possible to check the examples by cloning this repository and checking the `src/examples` folder.
There, core functionality of the Streaming Pool project are explained.

Keep in mind that Streaming Pool assumes that http://projects.spring.io/spring-framework/[Spring Framework] is used for managing the application Beans.

== Motivation
When connecting together heterogeneous and complex systems, it is not easy to exchange data between components. Streams of data are successfully used in industry in order to overcome this problem, especially in the case of "live" data. Streams are a specialization of the Observer design pattern and they provide asynchronous and non-blocking data flow.

The ongoing effort of the http://reactivex.io/[ReactiveX] initiative is one example that demonstrates how demanding this technology is even for big companies. Bridging the discrepancies of different technologies with common interfaces is already done by the http://www.reactive-streams.org/[Reactive Streams] initiative and, in the JVM world, via https://github.com/reactive-streams/reactive-streams-jvm[reactive-streams-jvm] interfaces.

Streaming Pool is a framework for providing and discovering reactive streams. Through the mechanism of dependency injection provided by the http://projects.spring.io/spring-framework/[Spring Framework], Streaming Pool provides a so called `DiscoveryService`. This object can discover and chain streams of data that are technologically agnostic, through the use of `StreamId`. The stream to be discovered must be present in the Streaming Pool system (by providing it using the `ProvidingService`) or it must be possible to create it (using one of the registered `StreamFactory`). In the latter case, the stream is lazily created on demand.
The application (client) that uses a stream does not need to know which is the source of the information, it may be a component of the application itself or a distributed system. In this way, it is possible to create truly decoupled systems that are resilient to changes and are easy to mock or test.

== Introduction
A common use case in modern Software applications is to access the values of a particular source. In the context of Internet of Things the source can be a sensor or a device. In business applications the source can be a real time indicator or application state. At CERN a common problem is to listen to devices values of the control system.

All these problems can be solved using the well-known Observable-Observer pattern or, recently, a reactive stream of the data. Streaming Pool assumes you want to use a Reactive Stream for accessing your data.

There are technologies that already solve this problem, such as https://projectreactor.io/[Project Reactor] and https://github.com/ReactiveX/RxJava[RxJava].

The goal of Streaming Pool is to provide and discover Reactive Streams without having the knowledge of where they live (in the local VM or on a Server). The only knowledge you need to have is the ID or `StreamId` associated to the Reactive Stream you want to get.

=== Discover a stream
[source,java]
----
class AnyClass {
    @Autowired
    private DiscoveryService discoveryService;

    private StreamId<Double> deviceStreamId;

    public void anyMethod() {
        Publisher<Double> = discoveryService.discover(deviceStreamId);
        // ...
    }
}
----
In this example, the `Publisher` (Reactive Stream) related to the specified `deviceStreamId` is then returned. Behind the scenes, the Streaming Pool engine will check if it has a `StreamId` that matches the specified one.

[NOTE]
====
Keep in mind that you can query the for the same ID multiple times and you will get the same instance of the `Publisher` (like in a `Map<StreamId<T>, Publisher<T>>`).
====

=== Provide a stream
[source,java]
----
class AnyClass {
    @Autowired
    private ProvidingService providingService;

    private StreamId<Double> deviceStreamId;

    public void anyMethod() {
        // ...
        Publisher<Double> deviceStream = createStream();
        providingService.discover(deviceStreamId, deviceStream);
        // ...
    }
}
----
In the case you want to provide a Reactive Stream, you can easily do so by using the `ProvidingService` interface. It has a single method that will register in the Streaming Pool system the given `Publisher` associated to the given `StreamId`. Later on, you can discover the stream by querying a `DiscoveryService` with the same `StreamId`.

[NOTE]
====
It is currently not possible to remove a Reactive Stream from the Streaming Pool. This feature is scheduled to be implemented, but it is not part of the current development.
====

=== How to lazily create Reactive Streams

=== How discovery works

== Examples

